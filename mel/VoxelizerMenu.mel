// Create a named instance of the voxel paint context command to reuse so it retains user settings
global string $voxelPaintContext;

global proc VoxelizerMenu() {
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }

    string $selection[] = `ls -selection`;
    if (size($selection) <= 0) {
        warning("No mesh selected to voxelize.");
        return;
    }
    string $selectedMeshName = $selection[0];

    string $ret[] = createVoxelGridDisplay($selectedMeshName);
    string $voxelGridDisplayName = $ret[0];
    float $scale[]  = { float($ret[1]), float($ret[2]), float($ret[3]) };
    float $center[] = { float($ret[4]), float($ret[5]), float($ret[6]) };

    window -title "Voxelizer Menu" VoxelizerMenuWindow;
    formLayout VoxelizerMenuForm;

    // Instruction text
    string $instructionText = `text -label "Use fields below to control the voxelization, or scale the box in the viewport using the manipulators"`;

    // Spacer for top padding
    string $spacer = `separator -style "none"`;

    // Position controls
    string $positionField = `floatFieldGrp -numberOfFields 3 -label "Position: " -value1 $center[0] -value2 $center[1] -value3 $center[2]
        -cc ("VoxelizerMenu_updatePosition(\"" + $voxelGridDisplayName + "\", #1, #2, #3)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Scale controls
    string $scaleField = `floatFieldGrp -numberOfFields 3 -label "Scale: " -value1 $scale[0] -value2 $scale[1] -value3 $scale[2]
        -cc ("VoxelizerMenu_updateScale(\"" + $voxelGridDisplayName + "\", #1, #2, #3)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Subdivision controls
    string $subdivField = `intSliderGrp -label "Voxels Per Edge: " -value 1 -field true -minValue 2 -maxValue 32 -fieldMinValue 2 -fieldMaxValue 64
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50`;

    string $surfaceCheckbox = `checkBox -label "Surface" -value true`;
    string $solidCheckbox = `checkBox -label "Solid" -value true`;
    string $renderAsVoxelsCheckbox = `checkBox -label "Render As Voxels" -value false`;
    string $clipTrianglesCheckbox = `checkBox -label "Clip Triangles" -value true`;

    // Buttons
    string $cancelButton = `button -label "Cancel" -command ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")")`;
    string $runButton = `button -label "Voxelize" 
        -annotation "Voxelizes a mesh in preparation for VGS simulation. Uses selected mesh or, if none selected, the closest mesh to the center of the grid bounds."
        -command ("VoxelizerMenu_run(\"" + $voxelGridDisplayName + "\", \"" + $selectedMeshName + "\", \"" + $positionField + "\", \"" + $scaleField + "\", \"" + $subdivField + "\", \"" + $surfaceCheckbox + "\", \"" + $solidCheckbox + "\", \"" + $renderAsVoxelsCheckbox + "\", \"" + $clipTrianglesCheckbox + "\")")`;

    // Attach elements to form layout 
    formLayout -edit
        -attachForm $instructionText "top" 10 -attachForm $instructionText "left" 20 -attachForm $instructionText "right" 20
        -attachControl $spacer "top" 10 $instructionText
        -attachForm $positionField "left" 20 -attachControl $positionField "top" 10 $spacer -attachForm $positionField "right" 20
        -attachForm $scaleField "left" 20 -attachControl $scaleField "top" 10 $positionField -attachForm $scaleField "right" 20
        -attachForm $subdivField "left" 20 -attachControl $subdivField "top" 10 $scaleField -attachForm $subdivField "right" 20
        -attachForm $surfaceCheckbox "left" 20 -attachControl $surfaceCheckbox "top" 10 $subdivField
        -attachControl $solidCheckbox "left" 10 $surfaceCheckbox -attachControl $solidCheckbox "top" 10 $subdivField
        -attachControl $renderAsVoxelsCheckbox "left" 10 $solidCheckbox -attachControl $renderAsVoxelsCheckbox "top" 10 $subdivField
        -attachControl $clipTrianglesCheckbox "left" 10 $renderAsVoxelsCheckbox -attachControl $clipTrianglesCheckbox "top" 10 $subdivField
        -attachForm $runButton "left" 20 -attachControl $runButton "top" 15 $clipTrianglesCheckbox
        -attachForm $cancelButton "left" 80 -attachControl $cancelButton "top" 15 $clipTrianglesCheckbox
        -attachForm $runButton "bottom" 10 -attachForm $cancelButton "bottom" 10
        VoxelizerMenuForm;

    showWindow VoxelizerMenuWindow;

    // Detect when the window has closed and run the cancel function
    scriptJob -uiDeleted VoxelizerMenuWindow ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")");

    // Sync viewport changes to scale and translation with menu inputs
    scriptJob -attributeChange ($voxelGridDisplayName + ".translate") ("VoxelizerMenu_syncPosition(\"" + $voxelGridDisplayName + "\", \"" + $positionField + "\")");
    scriptJob -attributeChange ($voxelGridDisplayName + ".scale") ("VoxelizerMenu_syncScale(\"" + $voxelGridDisplayName + "\", \"" + $scaleField + "\")");
}

global proc VoxelizerMenu_run(string $cubeName, string $selectedMeshName, string $positionField, string $scaleField, string $subdivField, string $surfaceCheckbox, string $solidCheckbox, string $renderAsVoxelsCheckbox, string $clipTrianglesCheckbox) {
    float $posX = `floatFieldGrp -query -value1 $positionField`;
    float $posY = `floatFieldGrp -query -value2 $positionField`;
    float $posZ = `floatFieldGrp -query -value3 $positionField`;
    float $scaleX = `floatFieldGrp -query -value1 $scaleField`;
    float $scaleY = `floatFieldGrp -query -value2 $scaleField`;
    float $scaleZ = `floatFieldGrp -query -value3 $scaleField`;
    int $voxelsPerEdge = `intSliderGrp -query -value $subdivField`;
    int $surface = `checkBox -query -value $surfaceCheckbox`;
    int $solid = `checkBox -query -value $solidCheckbox`;
    int $renderAsVoxels = `checkBox -query -value $renderAsVoxelsCheckbox`;
    int $clipTriangles = `checkBox -query -value $clipTrianglesCheckbox`;
    int $type = $surface + ($solid * 2) + ($renderAsVoxels * 4) + ($clipTriangles * 8); // Convert checkboxes to a single integer

    // Construct the VoxelDestroyer command with the passed arguments
    string $command = "VoxelDestroyer -px " + $posX + " -py " + $posY + " -pz " + $posZ +
                                    " -sx " + $scaleX + " -sy " + $scaleY + " -sz " + $scaleZ + 
                                    " -v " + $voxelsPerEdge + " -n \"" + $selectedMeshName + "\"" + " -t " + $type + ";";

    // Execute the command and handle errors
    if (catch(eval($command))) {
        warning("VoxelDestroyer failed.");
    } else {
        VoxelizerMenu_close($cubeName);
    }
}

global proc string[] createVoxelGridDisplay(string $selectedMeshName) {
    // First get the bounding box of the selected object
    // The bounding box of an object is axis aligned. We want to get the oriented bounding box, so unrotate the object,
    // get the bounding box, then restore the rotation.
    float $originalRotation[] = `xform -q -ws -rotation $selectedMeshName`;
    xform -ws -rotation 0 0 0 $selectedMeshName;
    float $bbox[] = `xform -q -ws -bb $selectedMeshName`;
    xform -ws -rotation $originalRotation[0] $originalRotation[1] $originalRotation[2] $selectedMeshName;
    float $scale[] = {$bbox[3] - $bbox[0], $bbox[4] - $bbox[1], $bbox[5] - $bbox[2]};
    float $center[] = {(($bbox[3] + $bbox[0]) / 2.0), (($bbox[4] + $bbox[1]) / 2.0), (($bbox[5] + $bbox[2]) / 2.0)};

    // Create a polyCube and store its name
    string $voxelGridDisplay[] = `polyCube -n "VoxelGridDisplay" -w 1 -h 1 -d 1 -ch 1 -sx 2 -sy 2 -sz 2`;
    string $voxelGridDisplayName = $voxelGridDisplay[0];
    xform -ws -scale $scale[0] $scale[1] $scale[2] -translation $center[0] $center[1] $center[2] -rotation $originalRotation[0] $originalRotation[1] $originalRotation[2] $voxelGridDisplayName;

    // Hide the cube in the outliner
    setAttr ($voxelGridDisplayName + ".hiddenInOutliner") true;

    // Display the cube in wireframe mode
    setAttr ($voxelGridDisplayName + ".overrideEnabled") true;
    setAttr ($voxelGridDisplayName + ".overrideShading") 0;

    // Lock all attributes except translation and scaling
    string $attributes[] = `listAttr -keyable -settable $voxelGridDisplayName`;
    for ($attr in $attributes) {
        if (!(`gmatch $attr "translate*"` || `gmatch $attr "scale*"`)) {
            setAttr -lock true ($voxelGridDisplayName + "." + $attr);
        }
    }

    // Lock the node to prevent deletion
    lockNode -lock true $voxelGridDisplayName;

    // Return name + numeric values as strings: {name, sx, sy, sz, cx, cy, cz}
    string $out[] = {
        $voxelGridDisplayName,
        ("" + $scale[0]), ("" + $scale[1]), ("" + $scale[2]),
        ("" + $center[0]), ("" + $center[1]), ("" + $center[2])
    };
    return $out;
}

// Update position of the polyCube
global proc VoxelizerMenu_updatePosition(string $cubeName, float $x, float $y, float $z) {
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".translateX") $x;
        setAttr ($cubeName + ".translateY") $y;
        setAttr ($cubeName + ".translateZ") $z;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update scale of the polyCube
global proc VoxelizerMenu_updateScale(string $cubeName, float $scaleX, float $scaleY, float $scaleZ) {
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".scaleX") $scaleX;
        setAttr ($cubeName + ".scaleY") $scaleY;
        setAttr ($cubeName + ".scaleZ") $scaleZ;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update subdivisions of the polyCube
global proc VoxelizerMenu_updateSubdivisions(string $cubeName, int $subdivs) {
    if (`objExists $cubeName`) {
        // Get the construction history node
        string $history[] = `listHistory $cubeName`;
        string $polyCubeNode[] = `ls -type "polyCube" $history`; // Ensure this is treated as an array
        if (size($polyCubeNode) > 0) {
            setAttr ($polyCubeNode[0] + ".subdivisionsWidth") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsHeight") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsDepth") $subdivs;
        } else {
            warning("No polyCube history node found.");
        }
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Cancel and delete the voxel grid
global proc VoxelizerMenu_close(string $cubeName) {
    if (`objExists $cubeName`) {
        // Unlock the node if it is locked
        lockNode -lock false $cubeName;
        // Delete the node
        delete $cubeName;
    }
    // Close the menu
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }
}

// Sync position changes to the UI
global proc VoxelizerMenu_syncPosition(string $cubeName, string $positionField) {
    if (`objExists $cubeName`) {
        float $x = `getAttr ($cubeName + ".translateX")`;
        float $y = `getAttr ($cubeName + ".translateY")`;
        float $z = `getAttr ($cubeName + ".translateZ")`;
        floatFieldGrp -edit -value1 $x -value2 $y -value3 $z $positionField;
    }
}

// Sync scale changes to the UI
global proc VoxelizerMenu_syncScale(string $cubeName, string $scaleField) {
    if (`objExists $cubeName`) {
        float $scaleX = `getAttr ($cubeName + ".scaleX")`;
        float $scaleY = `getAttr ($cubeName + ".scaleY")`;
        float $scaleZ = `getAttr ($cubeName + ".scaleZ")`;
        floatFieldGrp -edit -value1 $scaleX -value2 $scaleY -value3 $scaleZ $scaleField;
    }
}

global proc VoxelizerMenu_addToShelf() {
    global string $voxelPaintContext;
    $voxelPaintContext = `voxelPaintContextCommand`;
    // Ensure the "VoxelDestroyer" shelf exists
    global string $gShelfTopLevel;
    if (!`shelfLayout -exists "VoxelDestroyer"`) {
        shelfLayout -p $gShelfTopLevel "VoxelDestroyer";
    }

    // Get all buttons in the "VoxelDestroyer" shelf
    string $buttons[] = `shelfLayout -query -childArray "VoxelDestroyer"`;

    // Check if the "VoxelDestroyer" button already exists
    int $exists = 0;
    for ($button in $buttons) {
        if (`shelfButton -query -label $button` == "VoxelDestroyer") {
            $exists = 1;
            break;
        }
    }

    // Add the "VoxelDestroyer" button if it doesn't exist
    if (!$exists) {
        shelfButton -parent "VoxelDestroyer"
            -label "VoxelDestroyer"
            -annotation "Run VoxelDestroyer Plugin"
            -image1 "Voxelize.png"
            -command "VoxelizerMenu();";
        
        // Also add a button for the live-interaction tool
        shelfButton -parent "VoxelDestroyer"
            -label "VoxelDragTool"
            -annotation "Interactively drag voxels in the viewport while previewing an animation"
            -image1 "VoxelDrag.png"
            -command "string $ctx = `voxelDragContextCommand`; setToolTo $ctx;";

        shelfButton -parent "VoxelDestroyer"
            -label "VoxelCollider"
            -annotation "Add a collider primitive to the simulation"
            -image1 "VoxelCollider.png"
            -command "createCollider -n PlaneCollider;"
            -menuItem "Plane Collider" "createCollider -n PlaneCollider;"
            -menuItem "Sphere Collider" "createCollider -n SphereCollider;"
            -menuItem "Capsule Collider" "createCollider -n CapsuleCollider;"
            -menuItem "Box Collider" "createCollider -n BoxCollider;"
            -menuItem "Cylinder Collider" "createCollider -n CylinderCollider;";

        shelfButton -parent "VoxelDestroyer"
            -label "VoxelPaintTool"
            -annotation "Paint simulation weights onto voxels"
            -image1 "VoxelPaint.png"
            -command "setToolTo $voxelPaintContext;"
            -doubleClickCommand "setToolTo $voxelPaintContext; toolPropertyWindow;";
    }

    shelfTabLayout -edit -selectTab "VoxelDestroyer" $gShelfTopLevel;
}

global proc VoxelizerMenu_removeFromShelf() {
    if (`shelfLayout -exists "VoxelDestroyer"`) {
        deleteUI -control "VoxelDestroyer";
    }
}

global proc float Voxelizer_max(float $a, float $b) {
    return ($a > $b) ? $a : $b;
}