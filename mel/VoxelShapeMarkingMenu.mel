// Note: the name of the procedure must match the shape node name + "DagMenuProc"
global proc VoxelShapeDagMenuProc( string $menu, string $child ) {
    setParent -m $menu;

    // Get the first shape node child that is not an intermediate object
    string $shapes[] = `listRelatives -s $child`;
    string $target = $child;
    for ($s in $shapes) {
        int $isIntermediate = (`attributeExists "intermediateObject" $s`) ? `getAttr ($s + ".intermediateObject")` : 0;
        if (!$isIntermediate) { $target = $s; break; }
    }
    string $childFlag = ( " -n \"" + $target + "\"");

    // Face mode (Paint face-to-face constraints)
    string $cmd = "changeVoxelEditMode -m 1" + $childFlag;
    menuItem -l "Paint Face-to-Face Constraints" -rp "SE" -c $cmd;

    // Particle mode (Paint particle weights)
    $cmd = "changeVoxelEditMode -m 2" + $childFlag;
    menuItem -l "Paint Particle Weights" -rp "SW" -c $cmd;

    // Face mode (Voxel selection mode)
    $cmd = "changeVoxelEditMode -m 0" + $childFlag;
    menuItem -l "Voxel Selection Mode" -rp "NE" -c $cmd;

    // Object mode
    $cmd = "changeVoxelEditMode -m 3" + $childFlag;
    menuItem -l "Object Mode" -rp "NW" -c $cmd;

    // Assign a material to voxelized interior
    // (This option is not a radial menu item for changing the voxel edit mode like the others above)
    menuItem -l "Assign Interior Voxel Material" -ia "" -subMenu true;
        menuItem -l "New Material..." -c ("VoxelShape_OpenMaterialPicker \"" + $target + "\"");
        // List existing materials in the scene
        menuItem -l "Existing Material..." -subMenu true;
            string $mats[] = `ls -mat`;
            for ($mat in $mats) {
                menuItem -l $mat -c ("VoxelShape__SetInteriorMaterial \"" + $target + "\" \"" + $mat + "\"");
            }
        setParent -menu ..;
    setParent -menu ..;
}

global proc string VoxelShape__GetOrCreateShadingGroup(string $shaderNode)
{
    string $sgs[] = `listConnections -s false -d true -type "shadingEngine" $shaderNode`;

    // Prefer the SG whose surfaceShader is actually connected from $shaderNode
    for ($sg in $sgs) {
        string $src[] = `listConnections -s true -d false ($sg + ".surfaceShader")`;
        if (size($src) > 0 && $src[0] == $shaderNode) return $sg;
    }

    if (size($sgs) > 0) return $sgs[0];

    // None exists yet: create one and hook it up
    string $newSg = `sets -renderable true -noSurfaceShader true -empty -name ($shaderNode + "SG")`;
    string $cmd = ("connectAttr -f \"" + $shaderNode + ".outColor\" \"" + $newSg + ".surfaceShader\"");

    // If outColor connection failed, try outValue
    int $err = catchQuiet( `connectAttr -f ($shaderNode + ".outColor") ($newSg + ".surfaceShader")` );
    if ($err) {
        catchQuiet( `connectAttr -f ($shaderNode + ".outValue") ($newSg + ".surfaceShader")` );
    }

    return $newSg;
}

// When assigning a material, we simply set the name of the shader node to a string attribute on the voxel shape.
// There, an attribute-changed callback will actually handle the assignment.
global proc VoxelShape__SetInteriorMaterial( string $shape, string $shaderNode ) {
    string $shadingGroup = VoxelShape__GetOrCreateShadingGroup($shaderNode);
    undoInfo -openChunk;
    setAttr ($shape + ".interiorMaterial") -type "string" $shadingGroup;
    undoInfo -closeChunk;
}

global proc Voxel__OnInteriorNewMaterialCreated(string $shape, string $shaderNode, string $shaderType)
{
    VoxelShape__SetInteriorMaterial($shape, $shaderNode);
    evalDeferred("deleteUI -window \"VoxelInteriorNewMaterialWindow\";");
}

// Use the same internal procs Maya uses to create the shader picker window
// But attach our own callback so we can assign the material to our voxel shape interior
global proc VoxelShape_OpenMaterialPicker(string $shape)
{
    source "buildShaderMenus.mel";
    source "createAndAssignShader.mel";
    source "renderCreateBarUI.mel";
    string $postCommand = ("Voxel__OnInteriorNewMaterialCreated \"" + $shape + "\" %node %type");
    
    int $winW = 300;
    int $winH = 730;

    string $win = "VoxelInteriorNewMaterialWindow";
    if (`window -exists $win`) deleteUI -window $win;
    window -title "Assign Interior Voxel Material" -rtf false -widthHeight $winW $winH $win;

    string $form = ($win + "_form");
    formLayout -p $win $form;
    setParent $form;
        string $filter = "shader/surface shader/volume rendernode/arnold/shader/surface rendernode/arnold/shader/volume";
        string $tl = createRenderNodeTreeLister($postCommand, $filter);
        string $closeBtn = `button -label "Close" -h 26 -c ("deleteUI -window \"" + $win + "\"")`;

        formLayout -e
            -af $tl "left" 1
            -af $tl "right" 1
            -af $tl "top" 1
            -ac $tl "bottom" 5 $closeBtn

            -af $closeBtn "left" 5
            -af $closeBtn "right" 5
            -af $closeBtn "bottom" 5
            $form;

    showWindow $win;
}