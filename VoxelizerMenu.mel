global proc VoxelizerMenu() {
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }

    string $voxelGridDisplayName = createVoxelGridDisplay();

    window -title "Voxelizer Menu" VoxelizerMenuWindow;
    formLayout VoxelizerMenuForm;

    // Instruction text
    string $instructionText = `text -label "Use fields below to control the voxelization, or scale the box in the viewport using the manipulators"`;

    // Spacer for top padding
    string $spacer = `separator -style "none"`;

    // Position controls
    string $positionField = `floatFieldGrp -numberOfFields 3 -label "Position:" -value1 0 -value2 0 -value3 0
        -cc ("VoxelizerMenu_updatePosition(\"" + $voxelGridDisplayName + "\", #1, #2, #3)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Scale controls
    string $scaleField = `floatFieldGrp -numberOfFields 1 -label "Scale:" -value1 1
        -cc ("VoxelizerMenu_updateScale(\"" + $voxelGridDisplayName + "\", #1)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Subdivision controls
    string $subdivField = `intSliderGrp -label "Voxels Per Edge:" -value 1 -field true -minValue 2 -maxValue 32
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50`;

    // Buttons
    string $cancelButton = `button -label "Cancel" -command ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")")`;
    string $runButton = `button -label "Voxelize" 
        -annotation "Voxelizes a mesh in preparation for VGS simulation. Uses selected mesh or, if none selected, the closest mesh to the center of the grid bounds."
        -command (
            "float $posX = `floatFieldGrp -query -value1 " + $positionField + "`; " +
            "float $posY = `floatFieldGrp -query -value2 " + $positionField + "`; " +
            "float $posZ = `floatFieldGrp -query -value3 " + $positionField + "`; " +
            "float $scale = `floatFieldGrp -query -value1 " + $scaleField + "`; " +
            "int $voxelsPerEdge = `intSliderGrp -query -value " + $subdivField + "`; " +
            "VoxelizerMenu_run(\"" + $voxelGridDisplayName + "\", $posX, $posY, $posZ, $scale, $voxelsPerEdge);"
        )`;

    // Attach elements to form layout
    formLayout -edit
        -attachForm $instructionText "top" 10 -attachForm $instructionText "left" 20 -attachForm $instructionText "right" 20
        -attachControl $spacer "top" 10 $instructionText
        -attachForm $positionField "left" 20 -attachControl $positionField "top" 10 $spacer -attachForm $positionField "right" 20
        -attachForm $scaleField "left" 20 -attachControl $scaleField "top" 10 $positionField -attachForm $scaleField "right" 20
        -attachForm $subdivField "left" 20 -attachControl $subdivField "top" 10 $scaleField -attachForm $subdivField "right" 20
        -attachForm $runButton "left" 20 -attachControl $runButton "top" 15 $subdivField
        -attachForm $cancelButton "left" 80 -attachControl $cancelButton "top" 15 $subdivField
        -attachForm $runButton "bottom" 10 -attachForm $cancelButton "bottom" 10
        VoxelizerMenuForm;

    showWindow VoxelizerMenuWindow;

    // Detect when the window has closed and run the cancel function
    scriptJob -uiDeleted VoxelizerMenuWindow ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")");

    // Sync viewport changes to scale and translation with menu inputs
    scriptJob -attributeChange ($voxelGridDisplayName + ".translate") ("VoxelizerMenu_syncPosition(\"" + $voxelGridDisplayName + "\", \"" + $positionField + "\")");
    scriptJob -attributeChange ($voxelGridDisplayName + ".scaleX") ("VoxelizerMenu_syncScale(\"" + $voxelGridDisplayName + "\", \"" + $scaleField + "\")");
}

global proc VoxelizerMenu_run(string $cubeName, float $posX, float $posY, float $posZ, float $scale, int $voxelsPerEdge) {
    // Deselect the cube if it's currently selected, so it's not a voxelization target itself
    if (`objExists $cubeName` && `objExists ($cubeName + ".visibility")`) {
        select -deselect $cubeName;
    }

    // Construct the VoxelDestroyer command with the passed arguments
    string $command = "VoxelDestroyer -px " + $posX + " -py " + $posY + " -pz " + $posZ +
                      " -s " + $scale + " -v " + $voxelsPerEdge + " -n \"" + $cubeName + "\"";

    // Execute the command and handle errors
    if (catch(eval($command))) {
        warning("VoxelDestroyer failed.");
    } else {
        VoxelizerMenu_close($cubeName);
    }
}

global proc string createVoxelGridDisplay() {
    // Create a polyCube and store its name
    string $voxelGridDisplay[] = `polyCube -n "VoxelGridDisplay" -w 1 -h 1 -d 1 -ch 1 -sx 2 -sy 2 -sz 2`;
    string $voxelGridDisplayName = $voxelGridDisplay[0];


    // Hide the cube in the outliner
    setAttr ($voxelGridDisplayName + ".hiddenInOutliner") true;

    // Display the cube in wireframe mode
    setAttr ($voxelGridDisplayName + ".overrideEnabled") true;
    setAttr ($voxelGridDisplayName + ".overrideShading") 0;

    // Effectively lock Y and Z scaling and connect them to X to enforce uniform scaling
    // Can't find a better way that allows Y and Z to continue to be moved
    connectAttr ($voxelGridDisplayName + ".scaleX") ($voxelGridDisplayName + ".scaleY");
    connectAttr ($voxelGridDisplayName + ".scaleX") ($voxelGridDisplayName + ".scaleZ");
    
    // Lock all attributes except translation and scaling
    string $attributes[] = `listAttr -keyable -settable $voxelGridDisplayName`;
    for ($attr in $attributes) {
        if (!(`gmatch $attr "translate*"` || `gmatch $attr "scale*"`)) {
            setAttr -lock true ($voxelGridDisplayName + "." + $attr);
        }
    }

    // Lock the node to prevent deletion
    lockNode -lock true $voxelGridDisplayName;

    // Return the name of the created voxel grid
    return $voxelGridDisplayName;
}

// Update position of the polyCube
global proc VoxelizerMenu_updatePosition(string $cubeName, float $x, float $y, float $z) {
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".translateX") $x;
        setAttr ($cubeName + ".translateY") $y;
        setAttr ($cubeName + ".translateZ") $z;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update scale of the polyCube
global proc VoxelizerMenu_updateScale(string $cubeName, float $scale) {
    // Only need to scale X, as Y and Z are connected
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".scaleX") $scale;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update subdivisions of the polyCube
global proc VoxelizerMenu_updateSubdivisions(string $cubeName, int $subdivs) {
    if (`objExists $cubeName`) {
        // Get the construction history node
        string $history[] = `listHistory $cubeName`;
        string $polyCubeNode[] = `ls -type "polyCube" $history`; // Ensure this is treated as an array
        if (size($polyCubeNode) > 0) {
            setAttr ($polyCubeNode[0] + ".subdivisionsWidth") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsHeight") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsDepth") $subdivs;
        } else {
            warning("No polyCube history node found.");
        }
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Cancel and delete the voxel grid
global proc VoxelizerMenu_close(string $cubeName) {
    if (`objExists $cubeName`) {
        // Unlock the node if it is locked
        lockNode -lock false $cubeName;
        // Delete the node
        delete $cubeName;
    }
    // Close the menu
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }
}

// Sync position changes to the UI
global proc VoxelizerMenu_syncPosition(string $cubeName, string $positionField) {
    if (`objExists $cubeName`) {
        float $x = `getAttr ($cubeName + ".translateX")`;
        float $y = `getAttr ($cubeName + ".translateY")`;
        float $z = `getAttr ($cubeName + ".translateZ")`;
        floatFieldGrp -edit -value1 $x -value2 $y -value3 $z $positionField;
    }
}

// Sync scale changes to the UI
global proc VoxelizerMenu_syncScale(string $cubeName, string $scaleField) {
    if (`objExists $cubeName`) {
        float $scale = `getAttr ($cubeName + ".scaleX")`;
        floatFieldGrp -edit -value1 $scale $scaleField;
    }
}

global proc VoxelizerMenu_addToShelf() {
    // Ensure the "Custom" shelf exists
    if (!`shelfLayout -exists "Custom"`) {
        shelfLayout "Custom";
    }

    // Get all buttons in the "Custom" shelf
    string $buttons[] = `shelfLayout -query -childArray "Custom"`;

    // Check if the "VoxelDestroyer" button already exists
    int $exists = 0;
    for ($button in $buttons) {
        if (`shelfButton -query -label $button` == "VoxelDestroyer") {
            $exists = 1;
            break;
        }
    }

    // Add the "VoxelDestroyer" button if it doesn't exist
    if (!$exists) {
        shelfButton -parent "Custom"
            -label "VoxelDestroyer"
            -annotation "Run VoxelDestroyer Plugin"
            -image1 "TypeSeparateMaterials_200.png"
            -command "VoxelizerMenu();";
    }
}

global proc VoxelizerMenu_removeFromShelf() {
    // Check if the "Custom" shelf exists
    if (`shelfLayout -exists "Custom"`) {
        // Get all buttons in the "Custom" shelf
        string $buttons[] = `shelfLayout -query -childArray "Custom"`;

        // Iterate through the buttons and remove the "VoxelDestroyer" button if it exists
        for ($button in $buttons) {
            if (`shelfButton -query -label $button` == "VoxelDestroyer") {
                deleteUI -control $button;
            }
        }
    }
}