global proc VoxelizerMenu() {
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }

    float $bbox[] = getBoundingBoxCenterAndExtentOfSelectedObj();
    string $voxelGridDisplayName = createVoxelGridDisplay($bbox[0], $bbox[1], $bbox[2], $bbox[3]);

    window -title "Voxelizer Menu" VoxelizerMenuWindow;
    formLayout VoxelizerMenuForm;

    // Instruction text
    string $instructionText = `text -label "Use fields below to control the voxelization, or scale the box in the viewport using the manipulators"`;

    // Spacer for top padding
    string $spacer = `separator -style "none"`;

    // Position controls
    string $positionField = `floatFieldGrp -numberOfFields 3 -label "Position: " -value1 $bbox[0] -value2 $bbox[1] -value3 $bbox[2]
        -cc ("VoxelizerMenu_updatePosition(\"" + $voxelGridDisplayName + "\", #1, #2, #3)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Scale controls
    string $scaleField = `floatFieldGrp -numberOfFields 1 -label "Scale: " -value1 $bbox[3]
        -cc ("VoxelizerMenu_updateScale(\"" + $voxelGridDisplayName + "\", #1)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50
        - precision 2`;

    // Subdivision controls
    string $subdivField = `intSliderGrp -label "Voxels Per Edge: " -value 1 -field true -minValue 2 -maxValue 32
        -cc ("VoxelizerMenu_updateSubdivisions(\"" + $voxelGridDisplayName + "\", #1)") 
        -columnAlign 1 "left" -columnWidth 1 80 -columnWidth 2 50`;

    // X-axis controls
    string $xAxisGroup = `rowLayout -numberOfColumns 2 -columnWidth2 200 200`;
    string $xtensionField = `floatFieldGrp -numberOfFields 1 -label "X Tension: " -value1 0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateTension(\"" + $voxelGridDisplayName + "\", \"xtension\", #1)")`;
    string $xcompressionField = `floatFieldGrp -numberOfFields 1 -label "X Compression: " -value1 -0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateCompression(\"" + $voxelGridDisplayName + "\", \"xcompression\", #1)")`;
    setParent ..;

    // Y-axis controls
    string $yAxisGroup = `rowLayout -numberOfColumns 2 -columnWidth2 200 200`;
    string $ytensionField = `floatFieldGrp -numberOfFields 1 -label "Y Tension: " -value1 0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateTension(\"" + $voxelGridDisplayName + "\", \"ytension\", #1)")`;
    string $ycompressionField = `floatFieldGrp -numberOfFields 1 -label "Y Compression: " -value1 -0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateCompression(\"" + $voxelGridDisplayName + "\", \"ycompression\", #1)")`;
    setParent ..;

    // Z-axis controls
    string $zAxisGroup = `rowLayout -numberOfColumns 2 -columnWidth2 200 200`;
    string $ztensionField = `floatFieldGrp -numberOfFields 1 -label "Z Tension: " -value1 0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateTension(\"" + $voxelGridDisplayName + "\", \"ztension\", #1)")`;
    string $zcompressionField = `floatFieldGrp -numberOfFields 1 -label "Z Compression: " -value1 -0.5
        -columnAlign 1 "left" -columnWidth 1 100 -columnWidth 2 80
        -cc ("VoxelizerMenu_updateCompression(\"" + $voxelGridDisplayName + "\", \"zcompression\", #1)")`;
    setParent ..;

    string $surfaceCheckbox = `checkBox -label "Surface" -value true`;
    string $solidCheckbox = `checkBox -label "Solid" -value true`;
    string $simulatedCheckbox = `checkBox -label "Simulated" -value true`;

    // Buttons
    string $cancelButton = `button -label "Cancel" -command ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")")`;
    string $runButton = `button -label "Voxelize" 
        -annotation "Voxelizes a mesh in preparation for VGS simulation. Uses selected mesh or, if none selected, the closest mesh to the center of the grid bounds."
        -command ("VoxelizerMenu_run(\"" + $voxelGridDisplayName + "\", \"" + $positionField + "\", \"" + $scaleField + "\", \"" + $subdivField + "\", \"" + $surfaceCheckbox + "\", \"" + $solidCheckbox + "\", \"" + $simulatedCheckbox + "\", \"" + $xtensionField + "\", \"" + $xcompressionField + "\", \"" + $ytensionField + "\", \"" + $ycompressionField + "\", \"" + $ztensionField + "\", \"" + $zcompressionField + "\")")`;

    // Attach elements to form layout
    formLayout -edit
        -attachForm $instructionText "top" 10 -attachForm $instructionText "left" 20 -attachForm $instructionText "right" 20
        -attachControl $spacer "top" 10 $instructionText
        -attachForm $positionField "left" 20 -attachControl $positionField "top" 10 $spacer -attachForm $positionField "right" 20
        -attachForm $scaleField "left" 20 -attachControl $scaleField "top" 10 $positionField -attachForm $scaleField "right" 20
        -attachForm $subdivField "left" 20 -attachControl $subdivField "top" 10 $scaleField -attachForm $subdivField "right" 20
        -attachForm $xAxisGroup "left" 20 -attachControl $xAxisGroup "top" 10 $subdivField -attachForm $xAxisGroup "right" 20
        -attachForm $yAxisGroup "left" 20 -attachControl $yAxisGroup "top" 10 $xAxisGroup -attachForm $yAxisGroup "right" 20
        -attachForm $zAxisGroup "left" 20 -attachControl $zAxisGroup "top" 10 $yAxisGroup -attachForm $zAxisGroup "right" 20
        -attachForm $surfaceCheckbox "left" 20 -attachControl $surfaceCheckbox "top" 10 $zAxisGroup
        -attachControl $solidCheckbox "left" 10 $surfaceCheckbox -attachControl $solidCheckbox "top" 10 $zAxisGroup
        -attachControl $simulatedCheckbox "left" 10 $solidCheckbox -attachControl $simulatedCheckbox "top" 10 $zAxisGroup
        -attachForm $runButton "left" 20 -attachControl $runButton "top" 15 $simulatedCheckbox
        -attachForm $cancelButton "left" 80 -attachControl $cancelButton "top" 15 $simulatedCheckbox
        -attachForm $runButton "bottom" 10 -attachForm $cancelButton "bottom" 10
        VoxelizerMenuForm;

    showWindow VoxelizerMenuWindow;

    // Detect when the window has closed and run the cancel function
    scriptJob -uiDeleted VoxelizerMenuWindow ("VoxelizerMenu_close(\"" + $voxelGridDisplayName + "\")");

    // Sync viewport changes to scale and translation with menu inputs
    scriptJob -attributeChange ($voxelGridDisplayName + ".translate") ("VoxelizerMenu_syncPosition(\"" + $voxelGridDisplayName + "\", \"" + $positionField + "\")");
    scriptJob -attributeChange ($voxelGridDisplayName + ".scaleX") ("VoxelizerMenu_syncScale(\"" + $voxelGridDisplayName + "\", \"" + $scaleField + "\")");
}

global proc VoxelizerMenu_run(string $cubeName, string $positionField, string $scaleField, string $subdivField, string $surfaceCheckbox, string $solidCheckbox, string $simulatedCheckbox, string $xtensionField, string $xcompressionField, string $ytensionField, string $ycompressionField, string $ztensionField, string $zcompressionField) {
    float $posX = `floatFieldGrp -query -value1 $positionField`;
    float $posY = `floatFieldGrp -query -value2 $positionField`;
    float $posZ = `floatFieldGrp -query -value3 $positionField`;
    float $scale = `floatFieldGrp -query -value1 $scaleField`;
    int $voxelsPerEdge = `intSliderGrp -query -value $subdivField`;
    int $surface = `checkBox -query -value $surfaceCheckbox`;
    int $solid = `checkBox -query -value $solidCheckbox`;
    int $simulated = `checkBox -query -value $simulatedCheckbox`;
    float $xtension = `floatFieldGrp -query -value1 $xtensionField`;
    float $xcompression = `floatFieldGrp -query -value1 $xcompressionField`;
    float $ytension = `floatFieldGrp -query -value1 $ytensionField`;
    float $ycompression = `floatFieldGrp -query -value1 $ycompressionField`;
    float $ztension = `floatFieldGrp -query -value1 $ztensionField`;
    float $zcompression = `floatFieldGrp -query -value1 $zcompressionField`;

    // Deselect the cube if it's currently selected, so it's not a voxelization target itself
    if (`objExists $cubeName` && `objExists ($cubeName + ".visibility")`) {
        select -deselect $cubeName;
    }

    int $type = $surface + ($solid * 2) + ($simulated * 4); // Convert checkboxes to a single integer

    // Construct the VoxelDestroyer command with the passed arguments
    string $command = "VoxelDestroyer -px " + $posX + " -py " + $posY + " -pz " + $posZ +
                      " -s " + $scale + " -v " + $voxelsPerEdge + " -n \"" + $cubeName + "\"" + 
                      " -t " + $type +
                      " -xtension " + $xtension + 
                      " -ytension " + $ytension + 
                      " -ztension " + $ztension + 
                      " -xcompression " + $xcompression + 
                      " -ycompression " + $ycompression + 
                      " -zcompression " + $zcompression + ";";

    // Execute the command and handle errors
    if (catch(eval($command))) {
        warning("VoxelDestroyer failed.");
    } else {
        VoxelizerMenu_close($cubeName);
    }
}

// Update tension for a specific axis
global proc VoxelizerMenu_updateTension(string $cubeName, string $axis, float $value) {
    if (`objExists $cubeName`) {
        string $attribute = $cubeName + "." + $axis;
        if (`attributeExists $axis $cubeName`) {
            setAttr $attribute $value;
        } else {
            warning("Attribute " + $axis + " does not exist on " + $cubeName);
        }
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update compression for a specific axis
global proc VoxelizerMenu_updateCompression(string $cubeName, string $axis, float $value) {
    if (`objExists $cubeName`) {
        string $attribute = $cubeName + "." + $axis;
        if (`attributeExists $axis $cubeName`) {
            setAttr $attribute $value;
        } else {
            warning("Attribute " + $axis + " does not exist on " + $cubeName);
        }
    } else {
        warning("Voxel grid display does not exist.");
    }
}

global proc float[] getBoundingBoxCenterAndExtentOfSelectedObj() {
    float $result[] = { 0, 0, 0, 1 };
    
    string $selection[] = `ls -selection`;
    if (size($selection) > 0) {
        // The bounding box of an object is not axis aligned if the object is rotated.
        // To get the correct bounding box, we need to unrotate the object first, then restore it after.
        float $originalRotation[] = `xform -q -ws -rotation $selection[0]`;
        xform -ws -rotation 0 0 0 $selection[0];
        float $bbox[] = `xform -q -ws -bb $selection[0]`;
        xform -ws -rotation $originalRotation[0] $originalRotation[1] $originalRotation[2] $selection[0];

        float $bboxMin[] = { $bbox[0], $bbox[1], $bbox[2] };
        float $bboxMax[] = { $bbox[3], $bbox[4], $bbox[5] };

        // Calculate the center of the bounding box
        $result[0] = ($bboxMin[0] + $bboxMax[0]) / 2;
        $result[1] = ($bboxMin[1] + $bboxMax[1]) / 2;
        $result[2] = ($bboxMin[2] + $bboxMax[2]) / 2;

        // Calculate the extents of the bounding box
        float $extentX = abs($bboxMax[0] - $bboxMin[0]);
        float $extentY = abs($bboxMax[1] - $bboxMin[1]);
        float $extentZ = abs($bboxMax[2] - $bboxMin[2]);

        $result[3] = Voxelizer_max(Voxelizer_max($extentX, $extentY), $extentZ);
    }

    return $result;
}

global proc string createVoxelGridDisplay(float $x, float $y, float $z, float $maxExtent) {
    // Create a polyCube and store its name
    string $voxelGridDisplay[] = `polyCube -n "VoxelGridDisplay" -w 1 -h 1 -d 1 -ch 1 -sx 2 -sy 2 -sz 2`;
    string $voxelGridDisplayName = $voxelGridDisplay[0];
    scale $maxExtent $maxExtent $maxExtent $voxelGridDisplayName;
    move $x $y $z $voxelGridDisplayName;

    // Hide the cube in the outliner
    setAttr ($voxelGridDisplayName + ".hiddenInOutliner") true;

    // Display the cube in wireframe mode
    setAttr ($voxelGridDisplayName + ".overrideEnabled") true;
    setAttr ($voxelGridDisplayName + ".overrideShading") 0;

    // Effectively lock Y and Z scaling and connect them to X to enforce uniform scaling
    // Can't find a better way that allows Y and Z to continue to be moved
    connectAttr ($voxelGridDisplayName + ".scaleX") ($voxelGridDisplayName + ".scaleY");
    connectAttr ($voxelGridDisplayName + ".scaleX") ($voxelGridDisplayName + ".scaleZ");
    
    // Add custom attributes for tension and compression
    addAttr -longName "xtension" -attributeType "float" -defaultValue 0.5 -keyable true $voxelGridDisplayName;
    addAttr -longName "xcompression" -attributeType "float" -defaultValue -0.5 -keyable true $voxelGridDisplayName;
    addAttr -longName "ytension" -attributeType "float" -defaultValue 0.5 -keyable true $voxelGridDisplayName;
    addAttr -longName "ycompression" -attributeType "float" -defaultValue -0.5 -keyable true $voxelGridDisplayName;
    addAttr -longName "ztension" -attributeType "float" -defaultValue 0.5 -keyable true $voxelGridDisplayName;
    addAttr -longName "zcompression" -attributeType "float" -defaultValue -0.5 -keyable true $voxelGridDisplayName;

    // Lock all attributes except translation, scaling, and custom attributes
    string $attributes[] = `listAttr -keyable -settable $voxelGridDisplayName`;
    for ($attr in $attributes) {
        if (!(`gmatch $attr "translate*"` || `gmatch $attr "scale*"` || 
              $attr == "xtension" || $attr == "xcompression" || 
              $attr == "ytension" || $attr == "ycompression" || 
              $attr == "ztension" || $attr == "zcompression")) {
            setAttr -lock true ($voxelGridDisplayName + "." + $attr);
        }
    }

    // Lock the node to prevent deletion
    lockNode -lock true $voxelGridDisplayName;

    // Return the name of the created voxel grid
    return $voxelGridDisplayName;
}

// Update position of the polyCube
global proc VoxelizerMenu_updatePosition(string $cubeName, float $x, float $y, float $z) {
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".translateX") $x;
        setAttr ($cubeName + ".translateY") $y;
        setAttr ($cubeName + ".translateZ") $z;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update scale of the polyCube
global proc VoxelizerMenu_updateScale(string $cubeName, float $scale) {
    // Only need to scale X, as Y and Z are connected
    if (`objExists $cubeName`) {
        setAttr ($cubeName + ".scaleX") $scale;
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Update subdivisions of the polyCube
global proc VoxelizerMenu_updateSubdivisions(string $cubeName, int $subdivs) {
    if (`objExists $cubeName`) {
        // Get the construction history node
        string $history[] = `listHistory $cubeName`;
        string $polyCubeNode[] = `ls -type "polyCube" $history`; // Ensure this is treated as an array
        if (size($polyCubeNode) > 0) {
            setAttr ($polyCubeNode[0] + ".subdivisionsWidth") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsHeight") $subdivs;
            setAttr ($polyCubeNode[0] + ".subdivisionsDepth") $subdivs;
        } else {
            warning("No polyCube history node found.");
        }
    } else {
        warning("Voxel grid display does not exist.");
    }
}

// Cancel and delete the voxel grid
global proc VoxelizerMenu_close(string $cubeName) {
    if (`objExists $cubeName`) {
        // Unlock the node if it is locked
        lockNode -lock false $cubeName;
        // Delete the node
        delete $cubeName;
    }
    // Close the menu
    if (`window -exists VoxelizerMenuWindow`) {
        deleteUI VoxelizerMenuWindow;
    }
}

// Sync position changes to the UI
global proc VoxelizerMenu_syncPosition(string $cubeName, string $positionField) {
    if (`objExists $cubeName`) {
        float $x = `getAttr ($cubeName + ".translateX")`;
        float $y = `getAttr ($cubeName + ".translateY")`;
        float $z = `getAttr ($cubeName + ".translateZ")`;
        floatFieldGrp -edit -value1 $x -value2 $y -value3 $z $positionField;
    }
}

// Sync scale changes to the UI
global proc VoxelizerMenu_syncScale(string $cubeName, string $scaleField) {
    if (`objExists $cubeName`) {
        float $scale = `getAttr ($cubeName + ".scaleX")`;
        floatFieldGrp -edit -value1 $scale $scaleField;
    }
}

global proc VoxelizerMenu_addToShelf() {
    // Ensure the "Custom" shelf exists
    if (!`shelfLayout -exists "Custom"`) {
        shelfLayout "Custom";
    }

    // Get all buttons in the "Custom" shelf
    string $buttons[] = `shelfLayout -query -childArray "Custom"`;

    // Check if the "VoxelDestroyer" button already exists
    int $exists = 0;
    for ($button in $buttons) {
        if (`shelfButton -query -label $button` == "VoxelDestroyer") {
            $exists = 1;
            break;
        }
    }

    // Add the "VoxelDestroyer" button if it doesn't exist
    if (!$exists) {
        shelfButton -parent "Custom"
            -label "VoxelDestroyer"
            -annotation "Run VoxelDestroyer Plugin"
            -image1 "TypeSeparateMaterials_200.png"
            -command "VoxelizerMenu();";
    }
}

global proc VoxelizerMenu_removeFromShelf() {
    // Check if the "Custom" shelf exists
    if (`shelfLayout -exists "Custom"`) {
        // Get all buttons in the "Custom" shelf
        string $buttons[] = `shelfLayout -query -childArray "Custom"`;

        // Iterate through the buttons and remove the "VoxelDestroyer" button if it exists
        for ($button in $buttons) {
            if (`shelfButton -query -label $button` == "VoxelDestroyer") {
                deleteUI -control $button;
            }
        }
    }
}

global proc float Voxelizer_max(float $a, float $b) {
    return ($a > $b) ? $a : $b;
}